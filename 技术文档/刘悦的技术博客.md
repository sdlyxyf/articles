


刘悦的技术博客      https://home.cnblogs.com/u/v3ucn/
Python3并发场景(CPU密集/IO密集)任务的并发方式的场景抉择(多线程threading/多进程multiprocessing/协程asyncio) https://www.cnblogs.com/v3ucn/p/16542155.html

一般情况下，大家对Python原生的并发/并行工作方式：进程、线程和协程的关系与区别都能讲清楚。甚至具体的对象名称、内置方法都可以如数家珍，这显然是极好的，但我们其实都忽略了一个问题，就是具体应用场景，三者的使用目的是一样的，话句话说，使用结果是一样的，都可以提高程序运行的效率，但到底那种场景用那种方式更好一点？

这就好比，目前主流的汽车发动机变速箱无外乎三种：双离合、CVT以及传统AT。主机厂把它们搭载到不同的发动机和车型上，它们都是变速箱，都可以将发动机产生的动力作用到车轮上，但不同使用场景下到底该选择那种变速箱？这显然也是一个问题。

所谓“无场景，不功能”，本次我们来讨论一下，具体的并发编程场景有哪些，并且对应到具体场景，应该怎么选择并发手段和方式。

什么是并发和并行？
在讨论场景之前，我们需要将多任务执行的方式进行一下分类，那就是并发方式和并行方式。教科书上告诉我们：并行是指两个或者多个事件在同一时刻发生；而并发是指两个或多个事件在同一时间间隔内发生。 在多道程序环境下，并发性是指在一段时间内宏观上有多个程序在同时运行，但在单处理机系统中，每一时刻却仅能有一道程序执行，故微观上这些程序只能是分时地交替执行。

好像有那么一点抽象，好吧，让我们务实一点，由于GIL全局解释器锁的存在，在Python编程领域，我们可以简单粗暴地将并发和并行用程序通过能否使用多核CPU来区分，能使用多核CPU就是并行，不能使用多核CPU，只能单核处理的，就是并发。就这么简单，是的，Python的GIL全局解释器锁帮我们把问题简化了， 这是Python的大幸？还是不幸？

Python中并发任务实现方式包含：多线程threading和协程asyncio，它们的共同点都是交替执行，而区别是多线程threading是抢占式的，而协程asyncio是协作式的，原理也很简单，只有一颗CPU可以用，而一颗CPU一次只能做一件事，所以只能靠不停地切换才能完成并发任务。

Python中并行任务的实现方式是多进程multiprocessing，通过multiprocessing库，Python可以在程序主进程中创建新的子进程。这里的一个进程可以被认为是一个几乎完全不同的程序，尽管从技术上讲，它们通常被定义为资源集合，其中资源包括内存、文件句柄等。换一种说法是，每个子进程都拥有自己的Python解释器，因此，Python中的并行任务可以使用一颗以上的CPU，每一颗CPU都可以跑一个进程，是真正的同时运行，而不需要切换，如此Python就可以完成并行任务。

什么时候使用并发？IO密集型任务
现在我们搞清楚了，Python里的并发运行方式就是多线程threading和协程asyncio，那么什么场景下使用它们？

一般情况下，任务场景，或者说的更准确一些，任务类型，无非两种：CPU密集型任务和IO密集型任务。

什么是IO密集型任务？IO就是Input-Output的缩写，说白了就是程序的输入和输出，想一想确实就是这样，您的电脑，它不就是这两种功能吗？用键盘、麦克风、摄像头输入数据，然后再用屏幕和音箱进行输出操作。

但输入和输出操作要比电脑中的CPU运行速度慢，换句话说，CPU得等着这些比它慢的输入和输出操作，说白了就是CPU运算一会，就得等这些IO操作，等IO操作完了，CPU才能继续运算一会，然后再等着IO操作，如图所示：
![输入图片说明](https://v3u.cn/v3u/Public/js/editor/attached/20220801200815_82635.png)

并发方式的选择：多线程threading还是协程asyncio？
既然涉及硬盘读写(数据库读写)、网络请求、文件打印等任务都算并发任务，那我们就真正地实践一下，看看不同的并发方式到底能提升多少效率？

一个简单的小需求，对本站数据进行重复抓取操作，并计算首页数据文本的行数：
	
	import requests  
	import time  	  
	  
	def download_site(url, session):  
	    with session.get(url) as response:  
	        print(f"下载了{len(response.content)}行数据")  	  
	  
	def download_all_sites(sites):  
	    with requests.Session() as session:  
	        for url in sites:  
	            download_site(url, session)  	  
	  
	if __name__ == "__main__":  	  
	    sites = ["https://v3u.cn"] * 50  
	    start_time = time.time()  
	    download_all_sites(sites)  
	    duration = time.time() - start_time  
	    print(f"下载了 {len(sites)}次，执行了{duration}秒")


在不使用任何并发手段的前提下，程序返回：


<!--stackedit_data:
eyJoaXN0b3J5IjpbLTUzMTE3MDQyMCw4NDY4MzM4NzddfQ==
-->